{
    "componentChunkName": "component---src-templates-md-template-js",
    "path": "/blogs/resume-tips-for-swe",
    "result": {"data":{"markdownRemark":{"html":"<h2 id=\"drafting\" style=\"position:relative;\"><a href=\"#drafting\" aria-label=\"drafting permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Drafting</h2>\n<ol>\n<li>Mindset\n<ol>\n<li>How is Résumé going to be used by interviewers\n<ol>\n<li>Mayby I can find some interviewers to give me some advice?</li>\n</ol>\n</li>\n<li>How is Résumé going to be used by recruiters\n1.</li>\n<li>How is résumé going to be used by you</li>\n<li>What is the information needed for a résumé?</li>\n</ol>\n</li>\n<li>Prerequisites:\n<ol>\n<li>Use HTML to build your résumé\n<ol>\n<li>Git - version control</li>\n<li>Componentize</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>Content\n<ol>\n<li>STAR</li>\n<li>Personal Projects</li>\n<li>Working Projects</li>\n</ol>\n</li>\n<li>Design\n<ol>\n<li>Tools you have for your design:\n<ol>\n<li>Font Family</li>\n<li>Bold</li>\n<li>Italic</li>\n<li>Color</li>\n<li>Capital</li>\n<li>indentation</li>\n</ol>\n</li>\n<li>Typography</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"西文字体\" style=\"position:relative;\"><a href=\"#%E8%A5%BF%E6%96%87%E5%AD%97%E4%BD%93\" aria-label=\"西文字体 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>《西文字体》</h2>\n<ol>\n<li>p28: 小说等正文排版中一般使用罗马正体，据说是衬线有助于水平方向视线的移动</li>\n<li>p29: 无衬线体虽然不像罗马正体那样适合小说之类的长文，但由于字形简介，在苛刻条件下也容易被识别，因此多用于报纸字典多标题、手册、户外道路指示牌等</li>\n<li>p63: 斜体的用法：强调；外来；书籍名</li>\n<li>p64: 连字符(\"-\")的使用：\n<ol>\n<li>两端强制对齐时，每行的密度会不一样；</li>\n<li>齐左不齐右排版时，则会出现特别短的一行，容易让人误解为是段落的结束</li>\n<li>用连字符把单词分割开，只要不连续数行出现，都不会导致阅读困难</li>\n<li>即使右端不对齐，在使用连字符后文章板块的右侧具有适当的凹凸才是最为理想的</li>\n<li>分割单词应该以“按照音节适当划分、不能引起歧义”。操作时Google这个单词，前面加上define，google的dictionary会告诉你哪里可以分割</li>\n</ol>\n</li>\n<li>p66: 连接号比连字符长，且有两种，短的叫半角连接号(option + \"-\")，长的叫全角连接号(option + shift + \"-\")。\n<ol>\n<li>短连接号为“从……到”到意思。</li>\n</ol>\n</li>\n<li>p87: 阅读西文实则是在读单词的形状\n<ol>\n<li>大写字母排出来的警告条文，阅读会疲倦。因为大写字母排版会导致每个单词的轮廓都是一样的长方形而缺乏特征</li>\n<li>小写字母比大写字母更容易突出单词的特征</li>\n</ol>\n</li>\n<li>p108:字体搭配\n<ol>\n<li>标题和正文需要两种字体时，作为基本方法，要么选择类似调性的字体来协调统一，或者干脆反其道使用对比强烈的字体组合，需要避免似是而非的字体组合</li>\n<li>衬线字体和无衬线字体搭配\n<ol>\n<li>Avenir或Futura这里几何无衬线体去搭配Bodoni或Walbaum这样的现代罗马正体</li>\n<li>或者Franklin Gothic这样年代久远的无衬线体去搭配Garamond或Galliard这样的古典罗马正体</li>\n</ol>\n</li>\n<li>对于商品目录等印刷品，正文使用无衬线体没有什么问题。但一般来说，需要长篇阅读的文章还是衬线体更为合适</li>\n</ol>\n</li>\n</ol>","frontmatter":{"date":"June 05, 2022","path":"/blogs/resume-tips-for-swe","tags":["blog","checkout dash b"],"title":"Art of One Pager","description":"HOW to compose résumé: Viewpoint from Software Developer"}}},"pageContext":{"prev":{"frontmatter":{"path":"/blogs/bash-shortcut-for-uscis-curling","tags":["blog","bash"],"password":null},"internal":{"content":"\n## Final command\n> Change {your-case-id} to the case ID looks like \"IOE123412341234\"\n```bash\nwhile true; do echo '----------------------------------------'; date; curl -s https://egov.uscis.gov/casestatus/mycasestatus.do\\?appReceiptNum\\={your-case-id} | pup 'h1 text{}'; sleep 300; done\n```\nExample output:\n```\n---------------------------------------\nSat Jun 11 09:10:10 PDT 2022\nCase Is Being Actively Reviewed By USCIS\n---------------------------------------\nSat Jun 11 09:15:12 PDT 2022\nCase Is Being Actively Reviewed By USCIS\n---------------------------------------\nSat Jun 11 09:20:13 PDT 2022\nCase Is Being Actively Reviewed By USCIS\n---------------------------------------\nSat Jun 11 09:25:14 PDT 2022\nCase Is Being Actively Reviewed By USCIS\n```\n\n## Explaination\n### Every 5 mins...\n```bash\nwhile true; do {your-commands} sleep 300; done\n```\n\n### Print the current time\n```bash\ndate\n```\n\n### Curl DOM of a web page\n```bash\ncurl -s {url}\n```\n* `-s` flag is to \"silent\" the progress bar printing.\n\n### DOM navigation\n```bash\npup {selector}\n```\n* pup: https://github.com/ericchiang/pup\n    * to install: `brew install pup`\n* `h1` is the css selector\n    * it can be a tag name like `h1`\n    * or it can be dom id like `#id`\n    * or class name `.class`\n* `text{}` can fetch the text inside of the dom object\n    * without this the output looks like `<h1>Your case is actively reviewed by USCIS</h1>`\n    * with this the output looks like `Your case is actively reviewed by USCIS`"}},"next":{"frontmatter":{"path":"/blogs/firestore-learning","tags":["blog","mymanual","firebase","firestore"],"password":null},"internal":{"content":"\n```toc\n```\n\n## Document-Dollection Model\n1. **Document** is similar to json dictionary, it contains one or multiple **fields** like below:\n```\nDocument\nbrid_type: \"swallow\"\nairspeed: 42.733\ncoconut_capacity: 0.62\nisNative: false\nicon: <binary data>\nvector: {\n    x: 36.4255\n    y: 25.1442,\n    z: 18.8816\n}\ndistances_traveled: [42, 39, 12, 42]\n```\n2. *Collection* is a collection of documents. It can ONLY contain documents.\n3. Document can be only < 1MB size.\n4. Document cannot contain another do cument. It can contain **sub-collection** but not other document directly.\n5. The root of a Firestore tree can only contain collections\n\n\n## Query Fundamentals\n![picture 57](images/1088f546f7610c493b736096fc47fd1f989476143839d3e0df84599bed1678d5.png)  \n1. To navigate in your database, we are will do something like: `firestore.collection(...).document(...).collection(...).document(...)`. Or, we can also access the data by providing a path to that document like this: `firestore.document(\"/users/user_123/workouts/workout_abc/history/05182017\")`\n2. In Firebase, query is **shallow** by default. If you grab a parent level document, sub collection will be grabbed.\n\n\n## Query Rules\n1. Firestore will index your fields with a \"type\". Indexing means the DB will \n![picture 59](images/d69814208d57dfcc4d996ed12242df5d796d4688893b6da929e53d4c24b18465.png)\n\n2. Idealy, query should only happen in one collections. For example we have a tree like this: [Restaurants] -> [Reviews]:\n    * We can query for one restaurant, what are the reviews which have more than 4 stars;\n    * Query spam among several collections is called Collection Group Query. For example, if we want to get all reviews higher than 4 stars amoung all restaurants, we need to define:\n        * Colleciton ID: \"reviews\"; Field path: \"rating\"; Index Scope: \"Collection group\"\n        * This will tell the DB to index the rating fields of every documents in any collection with ID of \"reviews\"\n        * The number of this kinds of CGQ is limited - 200\n        * This will index all the collections with the same name. So if there are some unrelated collections of Reviews, they will also be indexed.\n3. Firestore does not support \"query in one collection then use the queried information to make another query\". For example, we cannot query user document in users collections and then join the reviews from that user.\n4. Fields can only be queried by using \">\", \"<\", \"==\". (Because they are sorted.) The idea of Firestore querying is, it will only do query by a. finding one point in the sorted index(using binary search); b. grab adjacent items of that point. For example, \"or\" and \"not\" queries are not supported.\n5. We can join two fields in one collection, for example, we can do \"query all restaurants **city=='SF' and cuisine=='Japanese'**\". This is done by doing \"zig-zag\" querying.\n    ![picture 65](images/8c56796cf1fb4bd8eeeddce02aaa194e6ef268f9d5ef3b5e412bdb4834258af9.png)\n    * Above Zig-zag query makes sense when the query is \"equal and equal\". For \"**less and equal**\" type of query, it's tricky, because the zig-zag only works when the ID is sorted, but for \"less-than\" query, ID is not sorted.\n    ![picture 66](images/a470972d8c16bbbfd7d93b2b5c774cea2065b9b96cfd5b508d7000e9930ab63b.png)  \n    * for this kind of query pattern, we can create `composite indexes` for this type of query - `zuocode_rating`:\n    ```json\n    {\n        restaurants:[{\n                name: \"BurgerThyme!\"\n                address: {\n                    addr_1: \"123 Fake Street\"\n                    city: \"San Francisco\"\n                    state: \"CA\"\n                    zip: \"94045\"\n                }\n                cuisine: \"Burgers\"\n                avg_rating: 4.76\n                zipcode_rating: \"94045_4.76\"\n            }]\n    }\n    ```\n    * Firestore can do this for us **automatically**. We can manually use Firestore UI to create this composite index or, we can run the query and Firestore will detect this kind of query and generate link for us to create them.\n    * With this technic, we can do \"equal\\equal\\equal\\...\\equal\\less_than(more_than)\" query.\n6. Array in Firestore does not support 'insertAt(idx, el)', 'deleteAt(idx, el)', 'retrieve(idx)'\n    * ![picture 63](images/a8efbb759341969c0e18eaf4ca7b1f2ddde16e6f99ab2b0a5f566557a0d5ef01.png)  \n    * For above collections, we can make query like: `collection(\"dickens_books\").where(\"keywords\", \"array-contains\", \"drama\")`\n    * This can be done because behind the scene, Firestore is converting the keywords list to a map: `keywords: [\"orphan\", \"crime\", \"London\", \"thieves\"]` -> `keywords: {\"orphan\": true, \"crime\": true, \"London\": true, \"thieves\": true}`\n\n## Data Structuring\n1. Do not make document too big (size[1mb max] and fields[20,000 fields]):\n    * Document has limits\n    * Document cannot be retrieved (and controlled by security rule) partially\n2. And, do NOT make document too small (fragmented)\n    * data retrieving is shallow\n    * you are billed by the number of reads and writes you perform\n    * Do not pre-maturely optimize the data structure in order to reduce billing\n    * Queries find documents in single collection\n3. Put data in the same document if they are always displayed together\n4. Put data in collection if **you are going to search for individual piece of the data or if you are expecting it to have rome to grow**\n5. As an exmaple of restaurants database, let's say we store \"reviews\" as a sub-collection under restaurant document. And in our app, we are going to display one restaurant with several (not all) reviews. For this use case, what we can do is create a field inside of restaurant document for \"**review_preview**\" and store latest (or some other order) reviews. We have Cloud Function to keep this in sync.\n6. For \"flag\" style data, we can either store a map of key->`true` or, we can store them in a list. But, according to the video, the approach of list will not allow you to do 2 attributes query. List is friendly for security rules, like \"who is allowed to edit the restaurant\".\n    ```json\n    {\n        name: \"some restaurant\"\n        cuisine: \"French\"\n        rating: 4.92\n        attributes: {\n            takes_reservations: true\n            romantic: true\n            kid_friendly: false\n        }\n        editors: [userID_2852, userID_4582]\n        // or, better solution for this editor list, so we can do security rule as:\n        // allow write if: restaurant.roles[userId] = \"editor\"\n        roles: {\n            userId_2852: \"editor\"\n            userId_4571: \"editor\"\n            userId_8123: \"owner\"\n        }\n        // however, this approach might leak some information for security reason, a better option is to store this kind of information outside of this collection\n        // or, we can have a sub-collection called \"private data\" and only contain this kinds of secrity data\n    }\n    ```\n\n## Security Rules\n> Below will not cover security coming from server libraries, for example: cloud functions.\n1. A security rulle will specify: \n    1. what specific documents you are securing\n    2. what logic you are going to secure them.\n2. here is an example of security rule, it really just an example, does not make too much sense\n    ```\n    service cloud.firestore {\n        match /databases/{database}/documents {\n            match /{document=**} {\n                // Completely locked\n                allow read, write: if false;\n            }\n            // ----------------------------------\n            match /restaurants/{restaurantID} {\n                // (i)\n            }\n            match /restaurants/{restaurantID}/reviews/{reviewID} {\n                // the rules placed here is the same as what it has in (ii)\n            }\n            // ----------------------------------\n            match /restaurants/{restaurantID} {\n                match /reviews/{reviewId} {\n                    // (ii)\n                    allow write: if reviewId == \"review_234\"\n                }\n            }\n            // ----------------------------------\n            match /myCollection/{docId} {\n                allow read: if request.auth.token.email.matches('.*google[.]com$');\n            }\n        }\n    }\n    ```\n3. the `{database}` in this rule is to \"wild cards\" all the database in firestore. 2 kinds of wildcard:\n    1. Single element wildcard - `{database}` or `restaurantID`:\n        1. it's just to say: go ahead and match a single path element, either a document or a collection, and stick it into a variable with the name that I specified here.\n        2. so at the place - (i), we will have a variable named `restaurantId` and its value is the ID of the restaurant doc\n        3. this variable will be available in nested security rule, like place (ii)\n    2. \"Rest of the document path wild card\" - `{document=**}`\n        1. it says: go ahead and match the rest of the path and stick it into this variable here\n        2. now the `document` will be the rest of the path\n4. **WARNING**: the security ruls for the parent document will not be cascade to the nested collection!\n5. **WARNING**: security rules will be an *ORDERED* matcher list. First will be applied and if it does not work, the second will be applied... So be careful of some \"powerful\" rules which can override following rules.\n6. For the rule string - `allow read: if reviewId == \"review_234\"`:\n    1. only `allow` keyword is provided. There is no `disallow`. If you want to \"block\", you can `allow read: if false`\n    2. verbs:\n        1. `read` includes `get` and `list`\n        2. `write` includes `create`, `delete` and `update`\n7. `request` is the \"input\" of the security rule. It contains 2 things:\n    1. auth\n        1. whether they're an actual signed-in user: `allow read: if request.auth != null`\n        2. allow people only when the email from the domain of \"google.com\" and verified: `allow read: if request.auth.token.email.matches( '.*google[.]com$') && request.auth.token.email_verified;`\n    2. resource\n        1. security rule can be used to \"define the data restriction\": `allow create: if request.resource.data.score is number && request.resource.data.score >= 1 && request.resource.data.score <= 5`\n        2. with \"resource\", we can also define some rules to \"only let the owner to edit/read the document\": `allow update: if request.resource.data.reviewerId = request.auth.uid`\n8. `resource` is another object can be used in security rules representing the existing document in database:\n    1. for example, user cannot change the score: `allow update: if request.resource.data.score == resource.data.score`\n9. **WARNING**: security rule is NOT a filter, it will block a request to a collection and any of the documents failed the security rule.\n10. `get()` function can allow you to retrieve data from another document for security rule validation:\n    1. `allow update: if get(/databases/$(database)/documents/restaurants/$(restaruantID)/ private_data/private).data.roles[request.auth.uid] in [\"editor\", \"owner\"]`\n11. Custom Auth Claim: Cloud function can be used to define some fields for security rules. The number is limited.\n12. Security Rule support functions:\n    ```\n    function doesUserHaveGoogleAccount() {\n        return request.auth.token.email.matches('.*google[.]com$') && request.auth.token.email_verified\n    }\n\n    //...\n    allow update: if doesUserHaveGoogleAccount()\n    ```\n\n## Pagination\n```javascript\nmyQuery = restaurantRef.whereField(\"city\", isEqualTo: \"Tokyo\")\n    .whereField(\"category\", isEqualTo: \"tempura)\n    .order(by: \"rating\", descending: true)\n    .limit(to: 20)\n```\nAbove query Will provide the first 20 documents matches this query.\n\nTo get the next batch of data:\n```javascript\nnextBatch = restaurantRef.whereField(\"city\", isEqualTo: \"Tokyo\")\n    .whereField(\"category\", isEqualTo: \"tempura)\n    .order(by: \"rating\", descending: true)\n    .limit(to: 20)\n    .start(after: [\"Tokyo\", \"tempura\", 4.9])\n// or \nnextBatch = myQuery.start(after: [\"Tokyo\", \"tempura\", 4.9])\n// however, this will potentially skip documents. \n// So we can do:\nmextBatch = myQuery.start(after: previousDoc)\n// previousDoc is the LAST document of the previous batch\n```\n\n**WARNING**: if the collection is constantly updated, for example some documents are deleted and inserted, those updates might be skipped. To avoid this, in the 2nd query, you should increase the `limit(to: 40)` then `60`.\n\n## Transactions\nBatch Write is for Atomic: DB will make sure that one batch write will success for all or failed for all'\n\nTransaction is for Most-up-to-date, 5 steps to perform a transaction: \n1. before writing to DB, it will first read the dcoument; \n2. then, client will have some logic to update the data in the document; \n3. the update will be performed; \n4. then, double check the right change was made; \n5. finally, all changes will be commited.\n\n**When we want to increment or decrement a value, we need to use transaction.**\n\n## Offline Support\n> On Andriod and iOS devices, offline support is enabled by default.\n### Read\nThe offline mode for read works in Firestore likes following:\n1. [online] You queried Firestore for the top 30 sushi restaurants in SF sorted by price\n2. [online] You queried for the top 30 burger restaurants in SF sorted by price\n3. [offline] now you can still query for top 30 restaurants in SF sorted by rating. This query will work across the cache data.\n\n### Write\nWhen you make a change to a document, that data will be store on the local device and whether you are online or not, you data will immediately give you the appearence that your change has gone into effect. Any real-time listeners that are watching this data will trigger with your updated data.\n\nBy the meantime Firebase will take your change and attempt to send it to the server. After you are online, Firebase library will update your data for reals, and will remove that pending write.\n\nAs a summary, offline write will be queued and will be replayed when device goes online. If multiple devices are writing the same document, last write (to the server, even it actually happened before the other) will be applied.\n\n### Notes:\n1. Firebase library for web is not enabled for offline support by default\n2. The callback function of `collection.add()` will not be triggered when it's in offline mode, because your app is still waiting for the response from the server. When use Firebase, because it has a cache, we don't need to add a callback to handle the fresh data.\n3. Transaction will fail in offline mode\n4. Offline cache is not indexed so the query will take some time.\n5. The default behavior is good enough to ensure a good offline experience.\n\n## Realtime Support\n> The main takeaway here is that you should start thinking of realtime as your default behavior, then only switch to one-time fetch call only when you have a good reason to make that change.\n\n## Cloud Function\n> When an database action is fired, you can hook a cloud function to this action and execute some custom logic.\n### Why?\n1. With cloud function, \"backend logic\" is hosted at the backend (instead of managed by client). So you can easily update it by deploying to backend instead of updating client application;\n2. Clients are not trustworthy;\n\n### Notes:\n1. Infinite loop: when you have a cloud function executed `onChange()`, and in this function you modify the data, the same function will be triggered again.\n2. admin serverside sdk will bypass the security rules.\n3. Lazy import is preferred because otherwise all of your cloud function will load those library"}}}},
    "staticQueryHashes": []}