{
    "componentChunkName": "component---src-templates-md-template-js",
    "path": "/readings/effective-java-chapter-3",
    "result": {"pageContext":{"html":"<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#item-10-obey-the-general-contract-when-overriding-equals\">Item 10: Obey the general contract when overriding equals</a></p>\n<ul>\n<li><a href=\"#the-easiest-way\">The easiest way...</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id=\"item-10-obey-the-general-contract-when-overriding-equals\" style=\"position:relative;\"><a href=\"#item-10-obey-the-general-contract-when-overriding-equals\" aria-label=\"item 10 obey the general contract when overriding equals permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Item 10: Obey the general contract when overriding equals</h2>\n<h3 id=\"the-easiest-way\" style=\"position:relative;\"><a href=\"#the-easiest-way\" aria-label=\"the easiest way permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The easiest way...</h3>\n<blockquote>\n<p>The easiest way to avoid problems is not to override the equals method, in which case each instance of the class is equal only to itself. This is the right thing to do if any of the following conditions apply:</p>\n</blockquote>\n<ol>\n<li>Each instance of the class is inherently unique.</li>\n<li>There is no need for the class to provide a \"logical equality\" test.</li>\n<li>A superclass has already overridden equals, and the superclass behavior is appropriate for this class.</li>\n<li>The class is private or package-private, and you are certain that its equals method will never be invoked.</li>\n</ol>\n<blockquote>\n<p>When a class is value class, overriding the equal method is appropriate. Few contracts you must adhere.</p>\n</blockquote>\n<ol>\n<li>Reflexive <code class=\"language-text\">x.equals(x)</code> must be <code class=\"language-text\">true</code>;</li>\n<li>Symmetric: <code class=\"language-text\">x.equals(y)</code> <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>  </mtext><mo>⟺</mo><mtext>  </mtext></mrow><annotation encoding=\"application/x-tex\">\\iff</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.549em;vertical-align:-0.024em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⟺</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span></span></span></span> <code class=\"language-text\">y.equals(x)</code></li>\n<li>Transitive: <code class=\"language-text\">x.equals(y)</code> and <code class=\"language-text\">y.equals(z)</code> <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext></mrow><annotation encoding=\"application/x-tex\">\\implies</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.549em;vertical-align:-0.024em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⟹</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span></span></span></span> <code class=\"language-text\">x.equals(z)</code></li>\n<li>Consistent: if <code class=\"language-text\">x.equals(y)</code> returns <code class=\"language-text\">true</code>, then any times of invocation will return the same value</li>\n<li>For any non-null reference value x, <code class=\"language-text\">x.equals(null)</code> must return <code class=\"language-text\">false</code></li>\n<li>Liskov Substitution principle: any important property of a type should also hold for all its subtypes so that any method written for the type should work equally well on its subtypes. Basically, a subclass is still a superclass and must ack like as one.</li>\n</ol>","date":"July 19, 2022","tags":["readings","effective java"],"title":"Effective Java: CP3 - Methods Common to All Objects (10-14)","description":"When and how to override the nonfinal Object methods."}},
    "staticQueryHashes": []}